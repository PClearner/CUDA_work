实现CUDA的热门算子
_____________________________________________________
1.gemm

代码学习来源：https://zhuanlan.zhihu.com/p/657632577

下面是对
“ii) 在TM = TN = 8的情况下，无论矩阵A还是矩阵B，从Shared Memory中取数时需要取连续的8个数，即便用LDS.128指令一条指令取四个数，也需要两条指令，由于一个线程的两条load指令的地址是连续的，那么同一个Warp不同线程的同一条load指令的访存地址就是被间隔开的，便存在着 Bank Conflict。”
以及贴主解决方案的解释。

首先本人认为贴主没有表达的一个点是它这个做法其实并没有彻底的解决bankconflict。但是确实做到了很大程度缓解bankconflict。要说有没有比它做法更好的，那肯定有，但是性能还真不一定有贴主这版本性能高。贴主是在保证float4的前提下做bank conflict处理的。事实上float4是比处理bank conflict快的。但是float4有一个问题就是你所开辟的空间必须是4的倍数，否则就报错。所以常规处理bank conflict的方式padding其实作用不是很大。

而贴主在处理bank问题时是将一次读取8个连续地址给差开来，下面是基于贴主的解释再增加一层解释，方便更好理解：
如果一次读4个float就已经让某些线程落在相同的bank，那么紧随其后的下一条读(往往地址上连续+4)还会产生相似的碰撞，于是连续两条指令都可能发生bank conflict。
这在某些矩阵取列向量或者小tile加载的场景下尤为常见：要想并行取列，就被迫用行主序的二维数组里“非连续”的列，导致warp里各线程访问模式非常容易出现规律性冲突。

float4优先级是比bank conflict高的！！！！！要尽量确保float4的前提下实现bank conflict。

_____________________________________________________






